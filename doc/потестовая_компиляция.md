Навигация: [Главная страница](main_Page.md)/[Система
ejudge](система_ejudge.md)/[Использование](использование.md)/[Потестовая
компиляция](потестовая_компиляция.md)

Поддерживается начиная с версии
[3.5.1](change/изменения_в_версии_3.5.1.md)

Конфигурационные переменные:
[`enable_multi_header`](serve.cfg/problem/enable_multi_header.md),
[`use_lang_multi_header`](serve.cfg/problem/use_lang_multi_header.md),
[`header_pat`](serve.cfg/problem/header_pat.md),
[`footer_pat`](serve.cfg/problem/footer_pat.md),
[`compiler_env_pat`](serve.cfg/problem/compiler_env_pat.md)

В режиме потестовой компиляции генерируется отдельный исполняемый файл
для каждого теста. При компиляции для каждого теста может быть задан
индивидуальный заголовочный или хвостовой файл и индивидуальные опции
компиляции.

По-прежнему, тестирование программы состоит из фазы компиляции и фазы
прогона на тестах, но в случае потестовой компиляции фаза компиляции
выдает в качестве результата .zip-архив со всеми скомпилированными
исполняемыми файлами.

При потестовой компиляции компиляция всегда выполняется для всех тестов
и не прерывается, если компиляция исполняемого файла для какого-либо
теста привела к ошибке компиляции. Поэтому в протоколе компиляции всегда
будут сообщения об ошибках и предупреждениях компиляции для всех тестов.
Однако, если компиляция хотя бы одного исполняемого файла была неудачна,
то вся стадия компиляции завершается с вердиктом ошибки компиляции.

При потестовой компиляции заголовочные, хвостовые и файлы опций
компиляции располагаются в каталоге с тестами.

Режим потестовой компиляции включается для каждой задачи индивидуально
или с помощью задания в абстрактной задаче положительного значения
конфигурационной переменной
[`enable_multi_header`](serve.cfg/problem/enable_multi_header.md).
Если включен режим потестовой компиляции, то должен быть задан хотя бы
один из шаблонов имен файлов: для заголовочного файла, для хвостового
файла или для файла с опциями компиляции. Могут быть заданы несколько
или все шаблоны имен файлов.

### Примеры

Предположим, что необходимо задать индивидуальный хвостовой файл для
каждого теста. Тогда конфигурация задачи может быть установлена
следующим образом:

`[problem]`  
`enable_multi_header`  
`footer_pat = "%03d_f"`

К шаблону, задаваемому в переменной `footer_pat` автоматически будет
добавлен суффикс исходных файлов языка программирования. Поэтому, если
сдается файл для компилятора `g++`, то хвостовые файлы должны иметь
имена `001_f.cpp`, `002_f.cpp`, `003_f.cpp` и так далее. Хвостовые файлы
должны находиться в каталоге с тестами к задаче (`tests` в каталоге
задачи).

Если дополнительно включить опцию `use_lang_multi_header`, например,

`[problem]`  
`enable_multi_header`  
`use_lang_multi_header`  
`footer_pat = "%03d_f"`

то кроме суффикса исходного файла языка программирования к шаблону будет
добавлено короткое имя языка программирования. Таким образом при сдаче
программы для компилятора `g++` хвостовые файлы должны иметь имена
`001_f.g++.cpp`, `002_f.g++.cpp`, `003_f.g++.cpp` и так далее. Обратите
внимание, что добавляется символ "точка" и далее короткое имя языка.

Предположим, что для каждого теста необходимо задать индивидуальные
опции компиляции (например, подключать специальный объектный файл и т.
п.). Тогда конфигурация задачи может быть установлена следующим образом:

`[problem]`  
`enable_multi_header`  
`compiler_env_pat = "%03d.inf"`

файлы потестовых опций компилятора должны находиться в каталоге с
тестами и иметь имена `001.inf` и т. д. Это — те же самые
[.inf-файлы](.inf-файлы.md), которые используются при
тестировании решения для установки параметров командной строки или
переменных окружения.

Для задания опций компилятора в .inf-файле может использоваться параметр
`compiler_env`, например

`compiler_env = "EJUDGE_FLAGS=-DTEST10"`

Здесь устанавливается переменная окружения `EJUDGE_FLAGS`. Она будет
передана в скрипт компиляции, который подставит значение этой переменной
окружения в командную строку компиляции.

Аналогично могут задаваться переменные окружения для программы проверки
стиля:

`style_checker_env = "DISABLE_X=1"`

Если на некотором тесте компилятор должен выдать ошибку компиляции,
например, когда проверяется, что сданный на проверку файл не позволяет
выполнять те или иные операции, например, если сдается класс C++, то
проверяется, что объект класса не может быть скопирован, то может
использоваться параметр `compiler_must_fail`

`compiler_must_fail`  
`source_stub = "002_s"`

В параметре `source_stub` указывается шаблон имени файла, который будет
использован чтобы все-таки скомпилировать исполняемую программу для
данного теста. К шаблону имени файла будет добавлен суффикс имени
исходного файла и короткое имя языка программирования (если установлена
опция `use_lang_multi_header`). Например, в случае сдачи программы для
компилятора g++ полное имя подставляемого исходного файла будет либо
`002_s.cpp`, либо `002_s.g++.cpp`. Подстановочный файл также должен
находиться в каталоге с тестами к задаче.
